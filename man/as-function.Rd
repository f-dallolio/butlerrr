% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/as_function2.R
\name{as-function}
\alias{as-function}
\alias{as_function2}
\alias{as_closure2}
\alias{as_predicate2}
\title{Convert to function}
\usage{
as_function2(
  x,
  env = global_env(),
  ...,
  arg = caller_arg(x),
  call = caller_env()
)

as_closure2(x, env = caller_env())

as_predicate2(x, ..., env = global_env())
}
\arguments{
\item{x}{A function, a formula, or a string.

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function with up to
two arguments: \code{.x} (single argument) or \code{.x} and \code{.y} (two arguments). The
\code{.} placeholder can be used instead of \code{.x}. This allows you to create very
compact anonymous functions (lambdas) with up to two inputs. Functions
created from formulas have a special class. Use \code{is_lambda()} to test for
it.

If a \strong{string}, the function is looked up in \code{env}. Note that this
interface is strictly for user convenience because of the scoping issues
involved. Package developers should avoid supplying functions by name and
instead supply them by value.

Unlike \link[rlang:as_function]{rlang::as_function}, \code{as_function2()} also
accepts a string input that includes namespace definition (e.g. \code{"pkg::fn"}
or \code{"pkg:::fn"}). This is passed to \link[base:parse]{base::str2lang} and
then evaluated in \code{env}.}

\item{env}{Environment in which to fetch the function in case \code{x} is a
string.}

\item{...}{These dots are for future extensions and must be empty.}

\item{arg}{An argument name as a string. This argument will be mentioned in
error messages as the input that is at the origin of a problem.}

\item{call}{The execution environment of a currently running function, e.g.
caller_env(). The function will be mentioned in error messages as the
source of the error. See the call argument of abort() for more
information..}
}
\description{
\code{as_function2} is an extension of
\link[rlang:as_function]{rlang::as_function} which transforms a one-sided
formula into a function and powers the lambda syntax.

The main difference is that it also accepts as string input that includes
namespace definition (e.g. \code{"pkg::fn"} or \code{"pkg:::fn"}).
}
\examples{
f <- as_function2(~ .x + 1)
f(10)

g <- as_function2(~ -1 * .)
g(4)

h <- as_function2(~ .x - .y)
h(6, 3)

as_function2("mean")
as_function2("base::mean")

# Functions created from a formula have a special class:
rlang::is_lambda(f)
rlang::is_lambda(as_function2(function() "foo"))
}
